name: CI

on:
  push:
    branches: ["main"]
  pull_request:
    branches: ["main"]

jobs:
  docker-ci:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Build the test stage image from your multi-stage Dockerfile
      - name: Build test image
        run: docker build --target test -t ragchatbot:test .

      # Run unit tests INSIDE the container with API_KEY from Actions secrets.
      # We pass it at runtime (-e), not at build time (safer; nothing baked into the image).
      # COVERAGE_FILE set to /tmp to avoid read-only filesystem issues
      - name: Run unit tests
        env:
          # Fallback to 'dev' so PRs from forks (which don't get secrets) still pass.
          API_KEY: ${{ secrets.API_KEY != '' && secrets.API_KEY || 'dev' }}
        run: docker run --rm -e API_KEY="${API_KEY}" -e COVERAGE_FILE=/tmp/.coverage -e CHROMA_DIR=/tmp/chroma ragchatbot:test

      # Run Ruff inside the same test image (no secret needed here)
      - name: Run linter
        run: docker run --rm ragchatbot:test /opt/venv/bin/ruff check .

      # Scan for vulnerabilities with Trivy
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: 'ragchatbot:test'
          format: 'table'
          exit-code: '1'
          ignore-unfixed: true
          vuln-type: 'os,library'
          severity: 'CRITICAL,HIGH'
